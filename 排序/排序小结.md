# 时间复杂度

##  平均时间复杂度
1. 插入排序 O(n^2)
2. 归并排序 O(nlogn)
3. 快速排序 O(nlogn)
4. 堆排序 O(nlogn)

# 原地排序
1. 插入排序
2. 快速排序 
3. 堆排序

# 额外空间
1. 插入排序 O(1)
2. 堆排序 O(1)   
>- 这两种排序方法都是直接在原地交换，所以没有使用额外的空间
3. 快速排序 
>- 虽然也是在原地排序，但是使用了递归，一共有logn层，所以需要开辟logn层的栈空间，以便logn返回的时候使用
4. 归并排序 O(n)
>- 实际上是O(logn + n)

# 稳定性
>- 排序前和排序后，相等元素的相对位置没有发生变化
1. 插入排序
2. 归并排序
>- 排序算法的稳定性和具体的实现是有关系的，代码的实现可能会导致原本稳定的排序不稳定，取决于当两个数相等的时候，你的操作是什么

>- ### ？：为什么快速排序和堆排序不是稳定排序
>	1. 快速排序在选定中间点的时候，可能会选到相等的元素，导致，相等元素之间的相对位置发生变化
> 2. 堆排序在构建堆的过程中[3,3,4], shiftUp和shiftDown都会
>- 可以在排序过程中增加一个函数来保持一定的稳定性，但是肯定会有一定的性能消耗

|算法名称|平均时间复杂度|原地排序|额外使用空间|稳定性|
|---|---|--|--|--|
|插入排序|O(n^2)|o|O(1)|o|
|归并排序|O(nlogn)|x|O(n + logn)|o|
|快速排序|O(nlogn)|o|O(logn)|x|
|堆排序|O(nlogn)|o|O(1)|x|

